// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class DeployIdentity extends EthereumEvent {
  get params(): DeployIdentity__Params {
    return new DeployIdentity__Params(this);
  }
}

export class DeployIdentity__Params {
  _event: DeployIdentity;

  constructor(event: DeployIdentity) {
    this._event = event;
  }

  get identity(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get recovery(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get wallet(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get name(): string {
    return this._event.parameters[4].value.toString();
  }

  get dataHash(): Bytes {
    return this._event.parameters[5].value.toBytes();
  }
}

export class IdentityFactory extends SmartContract {
  static bind(address: Address): IdentityFactory {
    return new IdentityFactory("IdentityFactory", address);
  }

  on(): boolean {
    let result = super.call("on", []);

    return result[0].toBoolean();
  }

  try_on(): CallResult<boolean> {
    let result = super.tryCall("on", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  deployIdentity(
    _identityOwner: Address,
    _identityRecovery: Address,
    _dataHash: Bytes,
    _name: string
  ): Address {
    let result = super.call("deployIdentity", [
      EthereumValue.fromAddress(_identityOwner),
      EthereumValue.fromAddress(_identityRecovery),
      EthereumValue.fromFixedBytes(_dataHash),
      EthereumValue.fromString(_name)
    ]);

    return result[0].toAddress();
  }

  try_deployIdentity(
    _identityOwner: Address,
    _identityRecovery: Address,
    _dataHash: Bytes,
    _name: string
  ): CallResult<Address> {
    let result = super.tryCall("deployIdentity", [
      EthereumValue.fromAddress(_identityOwner),
      EthereumValue.fromAddress(_identityRecovery),
      EthereumValue.fromFixedBytes(_dataHash),
      EthereumValue.fromString(_name)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  deployIdentity1(
    _identityOwner: Address,
    _identityRecovery: Address,
    _dataHash: Bytes
  ): Address {
    let result = super.call("deployIdentity", [
      EthereumValue.fromAddress(_identityOwner),
      EthereumValue.fromAddress(_identityRecovery),
      EthereumValue.fromFixedBytes(_dataHash)
    ]);

    return result[0].toAddress();
  }

  try_deployIdentity1(
    _identityOwner: Address,
    _identityRecovery: Address,
    _dataHash: Bytes
  ): CallResult<Address> {
    let result = super.tryCall("deployIdentity", [
      EthereumValue.fromAddress(_identityOwner),
      EthereumValue.fromAddress(_identityRecovery),
      EthereumValue.fromFixedBytes(_dataHash)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }
}

export class DeployIdentityCall extends EthereumCall {
  get inputs(): DeployIdentityCall__Inputs {
    return new DeployIdentityCall__Inputs(this);
  }

  get outputs(): DeployIdentityCall__Outputs {
    return new DeployIdentityCall__Outputs(this);
  }
}

export class DeployIdentityCall__Inputs {
  _call: DeployIdentityCall;

  constructor(call: DeployIdentityCall) {
    this._call = call;
  }

  get _identityOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _identityRecovery(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _dataHash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _name(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class DeployIdentityCall__Outputs {
  _call: DeployIdentityCall;

  constructor(call: DeployIdentityCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class ToggleSwitchCall extends EthereumCall {
  get inputs(): ToggleSwitchCall__Inputs {
    return new ToggleSwitchCall__Inputs(this);
  }

  get outputs(): ToggleSwitchCall__Outputs {
    return new ToggleSwitchCall__Outputs(this);
  }
}

export class ToggleSwitchCall__Inputs {
  _call: ToggleSwitchCall;

  constructor(call: ToggleSwitchCall) {
    this._call = call;
  }
}

export class ToggleSwitchCall__Outputs {
  _call: ToggleSwitchCall;

  constructor(call: ToggleSwitchCall) {
    this._call = call;
  }
}

export class DeployIdentity1Call extends EthereumCall {
  get inputs(): DeployIdentity1Call__Inputs {
    return new DeployIdentity1Call__Inputs(this);
  }

  get outputs(): DeployIdentity1Call__Outputs {
    return new DeployIdentity1Call__Outputs(this);
  }
}

export class DeployIdentity1Call__Inputs {
  _call: DeployIdentity1Call;

  constructor(call: DeployIdentity1Call) {
    this._call = call;
  }

  get _identityOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _identityRecovery(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _dataHash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class DeployIdentity1Call__Outputs {
  _call: DeployIdentity1Call;

  constructor(call: DeployIdentity1Call) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.outputValues[0].value.toAddress();
  }
}

export class ConstructorCall extends EthereumCall {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _controllerAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
